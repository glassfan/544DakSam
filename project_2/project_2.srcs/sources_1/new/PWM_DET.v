`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: Portland State University
// Engineer: Samuel Burkhart
// 
// Create Date: 04/18/2017 10:23:53 PM
// Design Name: ECE_544 Spring 2017 Project_1
// Module Name: PWM_DET
// Project Name: ece544_proj1
// Target Devices: Nexys4DDR board with Microblaze softcore
// Tool Versions: Vivado 2016.2
// Description: Module to calculate the duty cycle of 3 input channels representing the red, green, and blue PWM inputs to an RGB LED.
//   The input clock is set to 10MHz in the block design for the project, generated by the Vivado Clocking Wizard
//   Two 32-bit counters are used to track the total clocks and high clocks over a given duration.
//   The duration is either from positive transition on the signal (aka the PWM signal goes from low to high) or 1 second has passed.
//   If the duration is stopped due to a positive transition: the duty cycle is calculated as (high_cycles * 100) / total_cycles
//     The duty cycle for each channel is 8-bit as the value should only span 0-100 due to high_cycles always being at most equal to total_cycles
//     The driver of the RGB LED channels specifies that the signals are to be driven at no higher than 50% duty cycle, so it is unexpected to get
//     a Duty Cycle larger than that.
//     This algorithm utilizes the Vivado division to calculate the duty cycle in hardware.  Another approach would have been to output the 
//     counts and do the calculation of the Duty Cycle in the Microblaze.  This would have required a wider bus, or reduced counter sizes.
//     Another option would have been to implement a Xilinx LogiCORE IP Integer Divier using the Divider Generator.
//   If the duration is stopped due to reaching one second (where total_count > 10,000,000) the DC is set to zero and the counts reset to 0.
//     This is necessary to detect a PWM DC of 0, otherwise we are not able to see the positive transition and don't "see" the 0 duty cycle signal
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////

// The PWM count is used to reset the counter's so they don't get stuck when no edge is detected
// This value should be at least longer than the period of the PWM signal, generated by the timer counter module (4KHz or 250us).
// For a 10MHz input clock, a count to 10M will give a 1 second counter, While giving significant delay of 0 DC PWM signals, it was the most stable value based on experimentation.
`define PWM_COUNT 10000000

module PWM_DET(
	input					clk,
    input                   Red,
    input                   Green,
    input                   Blue,
    output    [7:0]         RedDC_out,
    output    [7:0]         GreenDC_out,
    output    [7:0]         BlueDC_out
    );
    
    // For each channel (Red, Green, Blue) we need:
    //   8-bit Duty Cycle
    //   32-bit Total Count
    //   32-bit High Count
    //   1-bit Previous Value
    reg     [7:0]         RedDC;
    reg     [31:0]        RedTotalCount;
    reg 	[31:0]		  RedHighCount;
    reg                   PrevRed;
    
    reg     [7:0]         GreenDC;
    reg     [31:0]        GreenTotalCount;
    reg     [31:0]        GreenHighCount;
    reg                   PrevGreen;
    
    reg     [7:0]         BlueDC;
    reg     [31:0]        BlueTotalCount;
    reg     [31:0]        BlueHighCount;
    reg                   PrevBlue;
    
    // Assign the output ports the value of the 8-bit reg variables for the Duty Cycle of each channel
    assign RedDC_out =      RedDC;
    assign GreenDC_out =    GreenDC;
    assign BlueDC_out =     BlueDC;
    
    // Initialize all of the values to 0
    initial begin
        RedDC               =   0;
        RedTotalCount       =   0;
        RedHighCount        =   0;
        PrevRed             =   0;
        
        GreenDC             =   0;
        GreenTotalCount     =   0;
        GreenHighCount      =   0;
        PrevGreen           =   0;
        
        BlueDC              =   0;
        BlueTotalCount      =   0;
        BlueHighCount       =   0;
        PrevBlue            =   0;
    end
    
    // Everything is evaluated at the positive edge of the 10MHz clock, or every 100ns
    always @(posedge clk)
    begin
        // For each channel, follow the same pattern:
        //  Check if a positive edge transition has occured
        //    if it has, calculate the duty cycle and reset the counts
        //  Check if the count has reached the max (1 second)
        //    if it has, set the DutyCycle and counts to 0, the PWM signal is flat
        //  Else, increment the total count
        //    if the PWM signal is high, increment the high count
        if (!PrevRed && Red) begin
            RedDC <= (RedHighCount * 100) / (RedTotalCount);
            RedTotalCount <= 0;
            RedHighCount <= 0;
        end else if (RedTotalCount > `PWM_COUNT) begin
            RedDC <= 0;
            RedTotalCount <= 0;
            RedHighCount <= 0;
        end else begin
            RedTotalCount <= RedTotalCount + 1;
            if(Red) RedHighCount <= RedHighCount + 1;
        end
        
        if (!PrevGreen && Green) begin
            GreenDC <= (GreenHighCount * 100) / (GreenTotalCount);
            GreenTotalCount <= 0;
            GreenHighCount <= 0;
        end else if (GreenTotalCount > `PWM_COUNT) begin
            GreenDC <= 0;
            GreenTotalCount <= 0;
            GreenHighCount <= 0;
        end else begin
            GreenTotalCount <= GreenTotalCount + 1;
            if(Green) GreenHighCount <= GreenHighCount + 1;   
        end
        
        if (!PrevBlue && Blue) begin
            BlueDC <= (BlueHighCount * 100) / (BlueTotalCount);
            BlueTotalCount <= 0;
            BlueHighCount <= 0;
        end else if (BlueTotalCount > `PWM_COUNT) begin
            BlueDC <= 0;
            BlueTotalCount <= 0;
            BlueHighCount <= 0;
        end else begin   
            BlueTotalCount <= BlueTotalCount + 1;     
            if(Blue) BlueHighCount <= BlueHighCount + 1;
        end
        
        // Update the Previous Values for all the channels, to enable positive edge detection
        PrevRed <= Red;
        PrevGreen <= Green;
        PrevBlue <= Blue;
    end
endmodule
